{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcLineCount = calcLineCount;\nexports.merge = merge;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_create = require(\"./create\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_array = require(\"../util/array\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*istanbul ignore end*/\n\n\nfunction calcLineCount(hunk) {\n  /*istanbul ignore start*/\n  var _calcOldNewLineCount =\n  /*istanbul ignore end*/\n  calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return (\n        /*istanbul ignore start*/\n        (0,\n        /*istanbul ignore end*/\n\n        /*istanbul ignore start*/\n        _parse\n        /*istanbul ignore end*/\n        .\n        /*istanbul ignore start*/\n        parsePatch\n        /*istanbul ignore end*/\n        )(param)[0]\n      );\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return (\n      /*istanbul ignore start*/\n      (0,\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      _create\n      /*istanbul ignore end*/\n      .\n      /*istanbul ignore start*/\n      structuredPatch\n      /*istanbul ignore end*/\n      )(undefined, undefined, base, param)\n    );\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines;\n      /*istanbul ignore end*/\n      // Mine inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines2;\n      /*istanbul ignore end*/\n      // Theirs inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines2 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines2\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines3;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines3 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines3\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      myChanges));\n\n      return;\n    } else if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines4;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines4 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines4\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      theirChanges));\n\n      return;\n    }\n  } else if (\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _array\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  arrayEqual\n  /*istanbul ignore end*/\n  )(myChanges, theirChanges)) {\n    /*istanbul ignore start*/\n    var _hunk$lines5;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines5 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines5\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    /*istanbul ignore start*/\n    var _hunk$lines6;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines6 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines6\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}","map":{"version":3,"mappings":"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","names":["_create","_parse","_array","calcLineCount","hunk","calcOldNewLineCount","lines","oldLines","newLines","undefined","merge","mine","theirs","base","loadPatch","ret","index","newFileName","fileNameChanged","oldFileName","oldHeader","newHeader","selectField","hunks","mineIndex","theirsIndex","mineOffset","theirsOffset","length","mineCurrent","oldStart","Infinity","theirsCurrent","hunkBefore","push","cloneHunk","mergedHunk","Math","min","newStart","mergeLines","param","test","parsePatch","Error","structuredPatch","patch","conflict","check","offset","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","_toConsumableArray","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","arrayStartsWith","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","arrayEqual","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","line","state","operation","matchChanges","changes","matchIndex","contextChanges","conflicted","change","match","substr","reduce","prev","removeChanges","delta","i","changeContent","forEach","myCount","theirCount"],"sources":["C:\\Users\\91805\\node_modules\\diff\\src\\patch\\merge.js"],"sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"]},"metadata":{},"sourceType":"script"}