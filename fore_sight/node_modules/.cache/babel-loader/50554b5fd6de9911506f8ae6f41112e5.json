{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePatch = parsePatch;\n/*istanbul ignore end*/\n\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}","map":{"version":3,"mappings":"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","names":["parsePatch","uniDiff","options","diffstr","split","delimiters","match","list","i","parseIndex","index","push","length","line","test","header","exec","parseFileHeader","hunks","parseHunk","strict","Error","JSON","stringify","fileHeader","keyPrefix","data","fileName","replace","substr","trim","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation"],"sources":["C:\\Users\\91805\\node_modules\\diff\\src\\patch\\parse.js"],"sourcesContent":["export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n"]},"metadata":{},"sourceType":"script"}