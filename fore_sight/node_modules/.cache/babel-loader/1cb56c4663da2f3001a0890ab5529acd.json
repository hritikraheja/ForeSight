{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Pending = require('./pending');\n\nvar utils = require('./utils');\n\nvar debug = require('debug')('mocha:runner');\n\nvar Runnable = require('./runnable');\n\nvar Suite = require('./suite');\n\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\n\n\nvar globals = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'XMLHttpRequest', 'Date', 'setImmediate', 'clearImmediate'];\nvar constants = utils.defineConstants(\n/**\n * {@link Runner}-related constants.\n * @public\n * @memberof Runner\n * @readonly\n * @alias constants\n * @static\n * @enum {string}\n */\n{\n  /**\n   * Emitted when {@link Hook} execution begins\n   */\n  EVENT_HOOK_BEGIN: 'hook',\n\n  /**\n   * Emitted when {@link Hook} execution ends\n   */\n  EVENT_HOOK_END: 'hook end',\n\n  /**\n   * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n   */\n  EVENT_RUN_BEGIN: 'start',\n\n  /**\n   * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n   */\n  EVENT_DELAY_BEGIN: 'waiting',\n\n  /**\n   * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n   */\n  EVENT_DELAY_END: 'ready',\n\n  /**\n   * Emitted when Root {@link Suite} execution ends\n   */\n  EVENT_RUN_END: 'end',\n\n  /**\n   * Emitted when {@link Suite} execution begins\n   */\n  EVENT_SUITE_BEGIN: 'suite',\n\n  /**\n   * Emitted when {@link Suite} execution ends\n   */\n  EVENT_SUITE_END: 'suite end',\n\n  /**\n   * Emitted when {@link Test} execution begins\n   */\n  EVENT_TEST_BEGIN: 'test',\n\n  /**\n   * Emitted when {@link Test} execution ends\n   */\n  EVENT_TEST_END: 'test end',\n\n  /**\n   * Emitted when {@link Test} execution fails\n   */\n  EVENT_TEST_FAIL: 'fail',\n\n  /**\n   * Emitted when {@link Test} execution succeeds\n   */\n  EVENT_TEST_PASS: 'pass',\n\n  /**\n   * Emitted when {@link Test} becomes pending\n   */\n  EVENT_TEST_PENDING: 'pending',\n\n  /**\n   * Emitted when {@link Test} execution has failed, but will retry\n   */\n  EVENT_TEST_RETRY: 'retry',\n\n  /**\n   * Initial state of Runner\n   */\n  STATE_IDLE: 'idle',\n\n  /**\n   * State set to this value when the Runner has started running\n   */\n  STATE_RUNNING: 'running',\n\n  /**\n   * State set to this value when the Runner has stopped\n   */\n  STATE_STOPPED: 'stopped'\n});\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object|boolean} [opts] - Options. If `boolean` (deprecated), whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts) {\n    super();\n\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    if (typeof opts === 'boolean') {\n      // TODO: remove this\n      require('./errors').deprecate('\"Runner(suite: Suite, delay: boolean)\" is deprecated. Use \"Runner(suite: Suite, {delay: boolean})\" instead.');\n\n      this._delay = opts;\n      opts = {};\n    } else {\n      this._delay = opts.delay;\n    }\n\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n    this.uncaught = this._uncaught.bind(this);\n\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug('trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:', reason);\n        this.uncaught(reason);\n      } else {\n        debug('trapped unhandled rejection from (probably) user code; re-emitting on process');\n\n        this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n\n}\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.immediately = global.setImmediate || process.nextTick;\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\n\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug('_addEventListener(): adding for event %s; %d current listeners', eventName, target.listenerCount(eventName));\n  /* istanbul ignore next */\n\n  if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {\n    debug('warning: tried to attach duplicate event listener for %s', eventName);\n    return;\n  }\n\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : new Map();\n  const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n\n  this._eventListeners.set(target, targetListeners);\n};\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\n\n\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\n\n\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n\n  this._eventListeners.clear();\n};\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\n\n\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (match) {\n      total++;\n    }\n  });\n  return total;\n};\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global); // non-enumerables\n\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n/**\n * Check for global variable leaks.\n *\n * @private\n */\n\n\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n\n  var ok = this._globals;\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n\n  this.prevGlobalsLength = globals.length;\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\n\n\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n\n  if (test.isPending() && !force) {\n    return;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n\n    throw createFatalError('Test failed after root suite execution completed!', err);\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {// some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n\n    if (!hook) {\n      return fn();\n    }\n\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n    hook.allowUncaught = self.allowUncaught;\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n\n      if (testError) {\n        self.fail(self.test, testError);\n      } // conditional skip\n\n\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err); // stop executing hooks, notify callee of hook err\n\n        return fn(err);\n      }\n\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\n\n\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n\n  return suites;\n};\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite; // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig; // some hooks may fail even now\n\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        } // report error suite\n\n\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    } // next test\n\n\n    test = tests.shift(); // all done\n\n    if (!test) {\n      return fn();\n    } // grep\n\n\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n\n      return;\n    } // static skip, no hooks are executed\n\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    } // execute test and hook(s)\n\n\n    self.emit(constants.EVENT_TEST_BEGIN, self.test = test);\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n\n        self.emit(constants.EVENT_TEST_END, test); // skip inner afterEach hooks below errSuite level\n\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test; // conditional skip within it\n\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n            self.emit(constants.EVENT_TEST_RETRY, test, err); // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || self.failures && suite._bail) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n\n\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n\n    if (!curr) {\n      return done();\n    } // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n\n\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next; // remove reference to test\n\n    delete self.test;\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n\n    self.runTests(suite, next);\n  });\n};\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\n\n\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError('Runner#uncaught() called with invalid context', this);\n  }\n\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  } // browser does not exit script when throwing in global.onerror()\n\n\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError('Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger', err);\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n\n  err.uncaught = true;\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed'); // Ignore error if already failed\n\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!'); // report 'pending test' retrospectively as failed\n\n    this.fail(runnable, err, true);\n    return;\n  } // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n\n\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {{files: string[], options: Options}} [opts] - For subclasses\n * @returns {Runner} Runner instance.\n */\n\n\nRunner.prototype.run = function (fn) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n  debug('run(): got options: %O', options);\n\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting'); // If there is an `only` filter\n\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n\n    this.state = constants.STATE_RUNNING;\n\n    if (this._delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  }; // references cleanup to avoid memory leaks\n\n\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  } // callback\n\n\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\n\n\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\n\n\nRunner.prototype.runAsync = async function runAsync() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n  return this;\n};\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\n\n\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\n\n\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\n\n\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    } // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n\n\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    } // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n\n\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    } // Opera and IE expose global variables for HTML element IDs (issue #243)\n\n\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\n\n\nfunction isError(err) {\n  return err instanceof Error || err && typeof err.message === 'string';\n}\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\n\n\nfunction thrown2Error(err) {\n  return new Error(`the ${utils.canonicalType(err)} ${stringify(err)} was thrown, throw an Error :)`);\n}\n\nRunner.constants = constants;\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;","map":{"version":3,"sources":["C:/Users/91805/node_modules/mocha/lib/runner.js"],"names":["EventEmitter","require","Pending","utils","debug","Runnable","Suite","HOOK_TYPE_BEFORE_EACH","constants","HOOK_TYPE_AFTER_EACH","HOOK_TYPE_AFTER_ALL","HOOK_TYPE_BEFORE_ALL","EVENT_ROOT_SUITE_RUN","STATE_FAILED","STATE_PASSED","STATE_PENDING","stackFilter","stackTraceFilter","stringify","createInvalidExceptionError","createUnsupportedError","createFatalError","isMochaError","errorConstants","globals","defineConstants","EVENT_HOOK_BEGIN","EVENT_HOOK_END","EVENT_RUN_BEGIN","EVENT_DELAY_BEGIN","EVENT_DELAY_END","EVENT_RUN_END","EVENT_SUITE_BEGIN","EVENT_SUITE_END","EVENT_TEST_BEGIN","EVENT_TEST_END","EVENT_TEST_FAIL","EVENT_TEST_PASS","EVENT_TEST_PENDING","EVENT_TEST_RETRY","STATE_IDLE","STATE_RUNNING","STATE_STOPPED","Runner","constructor","suite","opts","undefined","deprecate","_delay","delay","self","_globals","_abort","_opts","state","total","failures","_eventListeners","Map","on","test","type","retriedTest","parent","idx","tests","indexOf","checkGlobals","hook","_defaultGrep","grep","globalProps","uncaught","_uncaught","bind","unhandled","reason","promise","_removeEventListener","process","emit","_addEventListener","immediately","global","setImmediate","nextTick","prototype","target","eventName","listener","listenerCount","has","get","targetListeners","targetEventListeners","Set","add","set","removeListener","delete","size","dispose","removeAllListeners","forEach","clear","re","invert","_grep","_invert","grepTotal","eachTest","match","fullTitle","props","Object","keys","i","length","push","arr","arguments","concat","checkLeaks","ok","leaks","_allowedGlobals","prevGlobalsLength","filterLeaks","msg","map","e","join","fail","Error","err","force","isPending","code","MULTIPLE_DONE","isError","thrown2Error","stack","fullStackTrace","ignore","name","fn","dryRun","hooks","getHooks","next","currentRunnable","ctx","currentTest","setHookTitle","allowUncaught","listeners","run","cbHookRun","testError","error","pending","suites","errForbid","originalTitle","title","parentTitle","root","orig","errSuite","pop","hookUp","parents","reverse","hookDown","runTest","asyncOnly","runTests","slice","hookErr","_","after","err2","errSuite2","_bail","shift","forbidPending","origSuite","eSuite","retry","currentRetry","retries","clonedTest","clone","unshift","runSuite","done","curr","nextSuite","isBrowser","runnable","clearTimeout","isFailed","isPassed","abort","callback","rootSuite","options","end","failZero","begin","prepare","hasOnly","filterOnly","cleanReferencesAfterRun","cleanReferences","once","linkPartialObjects","value","runAsync","Promise","resolve","isParallelMode","workerReporter","filter","key","navigator","matched","split","message","canonicalType","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar Suite = require('./suite');\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runner}-related constants.\n   * @public\n   * @memberof Runner\n   * @readonly\n   * @alias constants\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Emitted when {@link Hook} execution begins\n     */\n    EVENT_HOOK_BEGIN: 'hook',\n    /**\n     * Emitted when {@link Hook} execution ends\n     */\n    EVENT_HOOK_END: 'hook end',\n    /**\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n     */\n    EVENT_RUN_BEGIN: 'start',\n    /**\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n     */\n    EVENT_DELAY_BEGIN: 'waiting',\n    /**\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n     */\n    EVENT_DELAY_END: 'ready',\n    /**\n     * Emitted when Root {@link Suite} execution ends\n     */\n    EVENT_RUN_END: 'end',\n    /**\n     * Emitted when {@link Suite} execution begins\n     */\n    EVENT_SUITE_BEGIN: 'suite',\n    /**\n     * Emitted when {@link Suite} execution ends\n     */\n    EVENT_SUITE_END: 'suite end',\n    /**\n     * Emitted when {@link Test} execution begins\n     */\n    EVENT_TEST_BEGIN: 'test',\n    /**\n     * Emitted when {@link Test} execution ends\n     */\n    EVENT_TEST_END: 'test end',\n    /**\n     * Emitted when {@link Test} execution fails\n     */\n    EVENT_TEST_FAIL: 'fail',\n    /**\n     * Emitted when {@link Test} execution succeeds\n     */\n    EVENT_TEST_PASS: 'pass',\n    /**\n     * Emitted when {@link Test} becomes pending\n     */\n    EVENT_TEST_PENDING: 'pending',\n    /**\n     * Emitted when {@link Test} execution has failed, but will retry\n     */\n    EVENT_TEST_RETRY: 'retry',\n    /**\n     * Initial state of Runner\n     */\n    STATE_IDLE: 'idle',\n    /**\n     * State set to this value when the Runner has started running\n     */\n    STATE_RUNNING: 'running',\n    /**\n     * State set to this value when the Runner has stopped\n     */\n    STATE_STOPPED: 'stopped'\n  }\n);\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object|boolean} [opts] - Options. If `boolean` (deprecated), whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts) {\n    super();\n    if (opts === undefined) {\n      opts = {};\n    }\n    if (typeof opts === 'boolean') {\n      // TODO: remove this\n      require('./errors').deprecate(\n        '\"Runner(suite: Suite, delay: boolean)\" is deprecated. Use \"Runner(suite: Suite, {delay: boolean})\" instead.'\n      );\n      this._delay = opts;\n      opts = {};\n    } else {\n      this._delay = opts.delay;\n    }\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx =\n          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n\n    this.uncaught = this._uncaught.bind(this);\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug(\n          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',\n          reason\n        );\n        this.uncaught(reason);\n      } else {\n        debug(\n          'trapped unhandled rejection from (probably) user code; re-emitting on process'\n        );\n        this._removeEventListener(\n          process,\n          'unhandledRejection',\n          this.unhandled\n        );\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug(\n    '_addEventListener(): adding for event %s; %d current listeners',\n    eventName,\n    target.listenerCount(eventName)\n  );\n  /* istanbul ignore next */\n  if (\n    this._eventListeners.has(target) &&\n    this._eventListeners.get(target).has(eventName) &&\n    this._eventListeners.get(target).get(eventName).has(listener)\n  ) {\n    debug(\n      'warning: tried to attach duplicate event listener for %s',\n      eventName\n    );\n    return;\n  }\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target)\n    ? this._eventListeners.get(target)\n    : new Map();\n  const targetEventListeners = targetListeners.has(eventName)\n    ? targetListeners.get(eventName)\n    : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n  this._eventListeners.set(target, targetListeners);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n  this._eventListeners.clear();\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n  if (test.isPending() && !force) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError(\n      'Test failed after root suite execution completed!',\n      err\n    );\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack =\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n\n    hook.allowUncaught = self.allowUncaught;\n\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError(\n      'Runner#uncaught() called with invalid context',\n      this\n    );\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError(\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\n      err\n    );\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    this.fail(runnable, err, true);\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {{files: string[], options: Options}} [opts] - For subclasses\n * @returns {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn, opts = {}) {\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n\n  debug('run(): got options: %O', options);\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    this.state = constants.STATE_RUNNING;\n    if (this._delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  };\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\nRunner.prototype.runAsync = async function runAsync(opts = {}) {\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || (err && typeof err.message === 'string');\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(\n    `the ${utils.canonicalType(err)} ${stringify(\n      err\n    )} was thrown, throw an Error :)`\n  );\n}\n\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;\n"]},"metadata":{},"sourceType":"script"}