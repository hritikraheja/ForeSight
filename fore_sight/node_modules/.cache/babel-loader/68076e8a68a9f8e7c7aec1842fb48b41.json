{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffJson = diffJson;\nexports.canonicalize = canonicalize;\nexports.jsonDiff = void 0;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(require(\"./base\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_line = require(\"./line\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/*istanbul ignore end*/\n\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n/*istanbul ignore start*/\n\nexports.jsonDiff = jsonDiff;\n/*istanbul ignore end*/\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize =\n/*istanbul ignore start*/\n_line\n/*istanbul ignore end*/\n.\n/*istanbul ignore start*/\nlineDiff\n/*istanbul ignore end*/\n.tokenize;\n\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/\n  var _this$options =\n  /*istanbul ignore end*/\n  this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      typeof v === 'undefined' ? undefinedReplacement : v\n    );\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return (\n    /*istanbul ignore start*/\n    _base\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ].prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n  );\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (\n  /*istanbul ignore start*/\n  _typeof(\n  /*istanbul ignore end*/\n  obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}","map":{"version":3,"mappings":"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","names":["_base","_line","objectPrototypeToString","Object","prototype","toString","jsonDiff","Diff","useLongestToken","tokenize","lineDiff","castInput","value","options","undefinedReplacement","stringifyReplacer","k","v","JSON","stringify","canonicalize","equals","left","right","call","replace","diffJson","oldObj","newObj","diff","obj","stack","replacementStack","replacer","key","i","length","canonicalizedObj","push","Array","pop","toJSON","_typeof","sortedKeys","hasOwnProperty","sort"],"sources":["C:\\Users\\91805\\node_modules\\diff\\src\\diff\\json.js"],"sourcesContent":["import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n"]},"metadata":{},"sourceType":"script"}